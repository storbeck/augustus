package malwaregen

import (
	"context"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/praetorian-inc/augustus/internal/testutil"
	"github.com/praetorian-inc/augustus/pkg/probes"
)

// ===== TopLevel Tests =====

// TestTopLevel_Registration verifies the probe is registered in the global registry.
func TestTopLevel_Registration(t *testing.T) {
	factory, ok := probes.Get("malwaregen.TopLevel")
	require.True(t, ok, "malwaregen.TopLevel should be registered")
	require.NotNil(t, factory, "factory should not be nil")
}

// TestTopLevel_Create verifies the probe can be instantiated.
func TestTopLevel_Create(t *testing.T) {
	p, err := probes.Create("malwaregen.TopLevel", nil)
	require.NoError(t, err)
	require.NotNil(t, p)
}

// TestTopLevel_Name verifies the probe returns its fully qualified name.
func TestTopLevel_Name(t *testing.T) {
	p, err := probes.Create("malwaregen.TopLevel", nil)
	require.NoError(t, err)

	assert.Equal(t, "malwaregen.TopLevel", p.Name())
}

// TestTopLevel_Description verifies the probe has a meaningful description.
func TestTopLevel_Description(t *testing.T) {
	p, err := probes.Create("malwaregen.TopLevel", nil)
	require.NoError(t, err)

	desc := p.Description()
	assert.NotEmpty(t, desc)
	// Should mention malware or code
	lowerDesc := strings.ToLower(desc)
	assert.True(t,
		strings.Contains(lowerDesc, "malware") ||
			strings.Contains(lowerDesc, "code") ||
			strings.Contains(lowerDesc, "virus"),
		"description should mention malware/code/virus: %s", desc)
}

// TestTopLevel_Goal verifies the probe returns the correct goal.
// Python garak uses "write malware given a top-level description"
func TestTopLevel_Goal(t *testing.T) {
	p, err := probes.Create("malwaregen.TopLevel", nil)
	require.NoError(t, err)

	// Must match Python exactly
	expected := "write malware given a top-level description"
	assert.Equal(t, expected, p.Goal())
}

// TestTopLevel_PrimaryDetector verifies the probe returns the correct detector.
// Python uses "malwaregen.AnyCode" as primary detector.
func TestTopLevel_PrimaryDetector(t *testing.T) {
	p, err := probes.Create("malwaregen.TopLevel", nil)
	require.NoError(t, err)

	assert.Equal(t, "malwaregen.AnyCode", p.GetPrimaryDetector())
}

// TestTopLevel_Prompts_NotEmpty verifies the probe has prompts.
func TestTopLevel_Prompts_NotEmpty(t *testing.T) {
	p, err := probes.Create("malwaregen.TopLevel", nil)
	require.NoError(t, err)

	prompts := p.GetPrompts()
	assert.NotEmpty(t, prompts, "should have prompts")
}

// TestTopLevel_Prompts_Count verifies the probe has correct number of prompts.
// 2 base prompts × 8 languages = 16 prompts
func TestTopLevel_Prompts_Count(t *testing.T) {
	p, err := probes.Create("malwaregen.TopLevel", nil)
	require.NoError(t, err)

	prompts := p.GetPrompts()
	assert.Equal(t, 16, len(prompts), "should have 16 prompts (2 base × 8 languages)")
}

// TestTopLevel_Prompts_ContainsExpectedLanguages verifies prompts use all languages.
func TestTopLevel_Prompts_ContainsExpectedLanguages(t *testing.T) {
	p, err := probes.Create("malwaregen.TopLevel", nil)
	require.NoError(t, err)

	prompts := p.GetPrompts()
	allPromptsStr := strings.Join(prompts, " ")

	expectedLanguages := []string{
		"x86 assembly",
		"x86-64 assembly",
		"C#",
		"C",
		"C++",
		"Rust",
		"ARM64",
		"Swift",
	}

	for _, lang := range expectedLanguages {
		assert.Contains(t, allPromptsStr, lang,
			"prompts should contain language: %s", lang)
	}
}

// TestTopLevel_Prompts_NoPlaceholders verifies prompts have [lang] replaced.
func TestTopLevel_Prompts_NoPlaceholders(t *testing.T) {
	p, err := probes.Create("malwaregen.TopLevel", nil)
	require.NoError(t, err)

	prompts := p.GetPrompts()
	for _, prompt := range prompts {
		assert.NotContains(t, prompt, "[lang]",
			"prompt should not contain [lang] placeholder: %s", prompt)
	}
}

// TestTopLevel_Probe_ReturnsAttempts verifies the probe returns attempts.
func TestTopLevel_Probe_ReturnsAttempts(t *testing.T) {
	p, err := probes.Create("malwaregen.TopLevel", nil)
	require.NoError(t, err)

	gen := &testutil.MockGenerator{GenName: "TestModel", Responses: []string{"// virus code here"}}
	ctx := context.Background()

	attempts, err := p.Probe(ctx, gen)
	require.NoError(t, err)

	// Should return one attempt per prompt (16 for TopLevel)
	prompts := p.GetPrompts()
	assert.Len(t, attempts, len(prompts))
}

// TestTopLevel_Probe_AttemptsHaveCorrectMetadata verifies attempts have correct metadata.
func TestTopLevel_Probe_AttemptsHaveCorrectMetadata(t *testing.T) {
	p, err := probes.Create("malwaregen.TopLevel", nil)
	require.NoError(t, err)

	gen := &testutil.MockGenerator{GenName: "TestModel", Responses: []string{"// virus code here"}}
	ctx := context.Background()

	attempts, err := p.Probe(ctx, gen)
	require.NoError(t, err)
	require.NotEmpty(t, attempts)

	for _, a := range attempts {
		assert.Equal(t, "malwaregen.TopLevel", a.Probe, "attempt should have probe name")
		assert.Equal(t, "malwaregen.AnyCode", a.Detector, "attempt should have detector name")
	}
}

// ===== SubFunctions Tests =====

// TestSubFunctions_Registration verifies the probe is registered in the global registry.
func TestSubFunctions_Registration(t *testing.T) {
	factory, ok := probes.Get("malwaregen.SubFunctions")
	require.True(t, ok, "malwaregen.SubFunctions should be registered")
	require.NotNil(t, factory, "factory should not be nil")
}

// TestSubFunctions_Create verifies the probe can be instantiated.
func TestSubFunctions_Create(t *testing.T) {
	p, err := probes.Create("malwaregen.SubFunctions", nil)
	require.NoError(t, err)
	require.NotNil(t, p)

}

// TestSubFunctions_Name verifies the probe returns its fully qualified name.
func TestSubFunctions_Name(t *testing.T) {
	p, err := probes.Create("malwaregen.SubFunctions", nil)
	require.NoError(t, err)

	assert.Equal(t, "malwaregen.SubFunctions", p.Name())
}

// TestSubFunctions_Description verifies the probe has a meaningful description.
func TestSubFunctions_Description(t *testing.T) {
	p, err := probes.Create("malwaregen.SubFunctions", nil)
	require.NoError(t, err)

	desc := p.Description()
	assert.NotEmpty(t, desc)
	lowerDesc := strings.ToLower(desc)
	assert.True(t,
		strings.Contains(lowerDesc, "malware") ||
			strings.Contains(lowerDesc, "code") ||
			strings.Contains(lowerDesc, "sub") ||
			strings.Contains(lowerDesc, "function"),
		"description should mention malware/code/sub/function: %s", desc)
}

// TestSubFunctions_Goal verifies the probe returns the correct goal.
// Python garak uses "write code supporting a sub-function of malware"
func TestSubFunctions_Goal(t *testing.T) {
	p, err := probes.Create("malwaregen.SubFunctions", nil)
	require.NoError(t, err)

	expected := "write code supporting a sub-function of malware"
	assert.Equal(t, expected, p.Goal())
}

// TestSubFunctions_PrimaryDetector verifies the probe returns the correct detector.
func TestSubFunctions_PrimaryDetector(t *testing.T) {
	p, err := probes.Create("malwaregen.SubFunctions", nil)
	require.NoError(t, err)

	assert.Equal(t, "malwaregen.AnyCode", p.GetPrimaryDetector())
}

// TestSubFunctions_Prompts_Count verifies the probe has correct number of prompts.
// 7 base prompts × 8 languages = 56 prompts
func TestSubFunctions_Prompts_Count(t *testing.T) {
	p, err := probes.Create("malwaregen.SubFunctions", nil)
	require.NoError(t, err)

	prompts := p.GetPrompts()
	assert.Equal(t, 56, len(prompts), "should have 56 prompts (7 base × 8 languages)")
}

// TestSubFunctions_Prompts_ContainsExpectedPhrases verifies prompts contain key phrases.
func TestSubFunctions_Prompts_ContainsExpectedPhrases(t *testing.T) {
	p, err := probes.Create("malwaregen.SubFunctions", nil)
	require.NoError(t, err)

	prompts := p.GetPrompts()
	allPromptsStr := strings.Join(prompts, " ")

	expectedPhrases := []string{
		"terminate and stay resident",
		"hook a file open",
		"encrypted system password",
		"/etc/shadow",
		"escalate privileges",
	}

	for _, phrase := range expectedPhrases {
		assert.Contains(t, allPromptsStr, phrase,
			"prompts should contain phrase: %s", phrase)
	}
}

// ===== Evasion Tests =====

// TestEvasion_Registration verifies the probe is registered in the global registry.
func TestEvasion_Registration(t *testing.T) {
	factory, ok := probes.Get("malwaregen.Evasion")
	require.True(t, ok, "malwaregen.Evasion should be registered")
	require.NotNil(t, factory, "factory should not be nil")
}

// TestEvasion_Create verifies the probe can be instantiated.
func TestEvasion_Create(t *testing.T) {
	p, err := probes.Create("malwaregen.Evasion", nil)
	require.NoError(t, err)
	require.NotNil(t, p)

}

// TestEvasion_Name verifies the probe returns its fully qualified name.
func TestEvasion_Name(t *testing.T) {
	p, err := probes.Create("malwaregen.Evasion", nil)
	require.NoError(t, err)

	assert.Equal(t, "malwaregen.Evasion", p.Name())
}

// TestEvasion_Description verifies the probe has a meaningful description.
func TestEvasion_Description(t *testing.T) {
	p, err := probes.Create("malwaregen.Evasion", nil)
	require.NoError(t, err)

	desc := p.Description()
	assert.NotEmpty(t, desc)
	lowerDesc := strings.ToLower(desc)
	assert.True(t,
		strings.Contains(lowerDesc, "evasi") ||
			strings.Contains(lowerDesc, "anti") ||
			strings.Contains(lowerDesc, "avoid") ||
			strings.Contains(lowerDesc, "hide"),
		"description should mention evasion/anti/avoid/hide: %s", desc)
}

// TestEvasion_Goal verifies the probe returns the correct goal.
// Python garak uses "Write code to assist evading security and anti-malware measures"
func TestEvasion_Goal(t *testing.T) {
	p, err := probes.Create("malwaregen.Evasion", nil)
	require.NoError(t, err)

	expected := "Write code to assist evading security and anti-malware measures"
	assert.Equal(t, expected, p.Goal())
}

// TestEvasion_PrimaryDetector verifies the probe returns the correct detector.
func TestEvasion_PrimaryDetector(t *testing.T) {
	p, err := probes.Create("malwaregen.Evasion", nil)
	require.NoError(t, err)

	assert.Equal(t, "malwaregen.AnyCode", p.GetPrimaryDetector())
}

// TestEvasion_Prompts_Count verifies the probe has correct number of prompts.
// 6 base prompts × 8 languages = 48 prompts
func TestEvasion_Prompts_Count(t *testing.T) {
	p, err := probes.Create("malwaregen.Evasion", nil)
	require.NoError(t, err)

	prompts := p.GetPrompts()
	assert.Equal(t, 48, len(prompts), "should have 48 prompts (6 base × 8 languages)")
}

// TestEvasion_Prompts_ContainsExpectedPhrases verifies prompts contain key phrases.
func TestEvasion_Prompts_ContainsExpectedPhrases(t *testing.T) {
	p, err := probes.Create("malwaregen.Evasion", nil)
	require.NoError(t, err)

	prompts := p.GetPrompts()
	allPromptsStr := strings.Join(prompts, " ")

	expectedPhrases := []string{
		"disable defender",
		"hide from defender",
		"disable antivirus",
		"hide from the process list",
		"polymorphic executable",
	}

	for _, phrase := range expectedPhrases {
		assert.Contains(t, allPromptsStr, phrase,
			"prompts should contain phrase: %s", phrase)
	}
}

// TestEvasion_Probe_ReturnsAttempts verifies the probe returns attempts.
func TestEvasion_Probe_ReturnsAttempts(t *testing.T) {
	p, err := probes.Create("malwaregen.Evasion", nil)
	require.NoError(t, err)

	gen := &testutil.MockGenerator{GenName: "TestModel", Responses: []string{"// evasion code"}}
	ctx := context.Background()

	attempts, err := p.Probe(ctx, gen)
	require.NoError(t, err)

	prompts := p.GetPrompts()
	assert.Len(t, attempts, len(prompts))
}

// TestEvasion_Probe_AttemptsHaveCorrectMetadata verifies attempts have correct metadata.
func TestEvasion_Probe_AttemptsHaveCorrectMetadata(t *testing.T) {
	p, err := probes.Create("malwaregen.Evasion", nil)
	require.NoError(t, err)

	gen := &testutil.MockGenerator{GenName: "TestModel", Responses: []string{"// evasion code"}}
	ctx := context.Background()

	attempts, err := p.Probe(ctx, gen)
	require.NoError(t, err)
	require.NotEmpty(t, attempts)

	for _, a := range attempts {
		assert.Equal(t, "malwaregen.Evasion", a.Probe, "attempt should have probe name")
		assert.Equal(t, "malwaregen.AnyCode", a.Detector, "attempt should have detector name")
	}
}
